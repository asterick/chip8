package{    import flash.display.*;	import flash.utils.ByteArray;	import flash.utils.Timer;	import flash.ui.Keyboard;	import flash.media.SoundChannel;	import flash.events.*;	import flash.geom.*;	import flash.net.*;        public class Chip8 extends MovieClip    {		private const NO_WAIT:int = -1;				        private var display:Display;        private var memory:Memory;		private var keys:Vector.<Boolean>;		private var mapping:Object;		private var mappedKeys:uint;		private var keyload:int;			private var delayTimer:uint;		private var soundTimer:uint;				private var index:uint;        private var registers:Vector.<uint>;        private var beep:SoundChannel;		public var message:Function = function(s:String, ... rest):void { };        public function Chip8():void		        {			mapping = {88:0,49:1,50:2,51:3,				81:4,87:5,69:6,65:7,				83:8,68:9,90:10,67:11,				52:12,82:13,70:14,86:15};			mappedKeys = 16;			keys = new Vector.<Boolean>();						keys.length = 16;			memory = new Memory();			display = new Display();			index = 0;			registers = new Vector.<uint>();			while( registers.length < 16 )				registers.push(0);							addChild(display);			addEventListener( Event.ADDED_TO_STAGE, addedToStage );		}				private function addedToStage( e:Event ):void		{			stage.addEventListener( KeyboardEvent.KEY_DOWN, keyPressed );			stage.addEventListener( KeyboardEvent.KEY_UP, keyReleased );						stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;		}				// --- Display clock --------		public function tick( e:Event = null ):void		{			try			{				for( var i = 0; i < 20; i++ )					step();			}			catch( e:Error )			{				message(e);			}			if( delayTimer > 0 )				delayTimer--;			if( soundTimer > 0 )			{				soundTimer--;			}			else if( beep )			{				beep.stop();				beep = null;			}		}				// --- Keyboard I/O ---------				public function remapKeys( e:MouseEvent = null ):void		{			mappedKeys = 0;		}				private function keyPressed( e:KeyboardEvent ):void		{			if( mappedKeys < 16 )			{				message( mappedKeys.toString(16), "mapped to", String.fromCharCode(e.charCode), "("+e.keyCode+")" );				mapping[ e.keyCode ] = mappedKeys++;				}			else			{							if( mapping[e.keyCode] == undefined )					return ;					if( keyload != NO_WAIT )					registers[keyload] = mapping[e.keyCode];					keys[mapping[e.keyCode]] = true;				keyload = NO_WAIT;			}		}				private function keyReleased( e:KeyboardEvent ):void		{			if( mapping[e.keyCode] == undefined )				return ;							keys[mapping[e.keyCode]] = false;		}        				public function load( data:ByteArray ):void		{			// Basic machine init			message( "Program Loaded:", data.length, "bytes" );            memory.reset( data );			// Running in low-res mode			display.superchip = false;				keyload = NO_WAIT;		}						// --- RUNTIME -------------------------------------		public function step():void		{			if( keyload != NO_WAIT )				return ;			var opcode = memory.op;						var i:uint;			var rd:uint = (opcode >> 8) & 0xF;			var rs:uint = (opcode >> 4) & 0xF;			var alu:uint = opcode & 0xF;			var imm:uint = opcode & 0xFF;			var addr:uint = opcode & 0xFFF;			//message( (memory.pc-2) + ":", opcode );			switch( opcode & 0xF000 )			{			// RCA System Call			case 0x0000:				switch( opcode & 0xFF0 )				{				// Scroll Down				case 0x0C0:					display.scrollDown(alu);					return ;				case 0x0E0:				case 0x0F0:					switch( addr )					{					// Clear Screen					case 0x0E0:						display.clearScreen();						return ;					// Return					case 0x0EE:						memory.pc = memory.stack;						return ;					// Scroll Right					case 0x0FB:						display.scrollRight();						return ;					// Scroll Left					case 0x0FC:						display.scrollLeft();						return ;					// Exit (Reset for us)					case 0x0FD:						memory.reset();						display.superchip = false;						return ;					// Go low-resolution					case 0x0FE:						display.superchip = false;						return ;					// Go high-resolution					case 0x0FF:						display.superchip = true;						return ;					}					break ;				}				break ;			// Program Jump			case 0x1000:				memory.pc = addr;				return ;			// Program Call			case 0x2000:				memory.stack = memory.pc;				memory.pc = addr;				return ;			// Skip on equal			case 0x3000:				if( registers[rd] == imm )					memory.pc += 2;				return ;			// Skip on not equal			case 0x4000:				if( registers[rd] != imm )					memory.pc += 2;				return ;			// Skip on registers equal			case 0x5000:				if( alu != 0 )					message( "SRE REGISTER COMPARE LOWER NIBBLE: ", alu );							if( registers[rd] == registers[rs] )					memory.pc += 2;				return ;			// Load constant			case 0x6000:				registers[rd] = imm;				return ;			// Add constant			case 0x7000:				registers[rd] = (registers[rd] + imm) & 0xFF;				return ;			case 0x8000:				switch(alu)				{					case 0x0:						registers[rd] = registers[rs];						return ;					case 0x1:						registers[rd] |= registers[rs];						return ;					case 0x2:						registers[rd] &= registers[rs];						return ;					case 0x3:						registers[rd] ^= registers[rs];						return ;					case 0x4:						registers[rd] += registers[rs];						registers[15] = ( registers[rd] > 0xFF ) ? 1 : 0;						registers[rd] &= 0xFF;						return ;					case 0x5:						registers[rd] -= registers[rs];						registers[15] = ( registers[rd] > 0xFF ) ? 0 : 1;						registers[rd] &= 0xFF;						return ;					case 0x6:						registers[15] = registers[rd] & 1;						registers[rd] = registers[rd] >> 1;						return ;					case 0x7:						registers[rd] = registers[rs] - registers[rd];						registers[15] = ( registers[rd] > 0xFF ) ? 0 : 1;						registers[rd] &= 0xFF;						return ;					case 0xE:						registers[15] = registers[rd] >> 7;						registers[rd] = (registers[rd] << 1) & 0xFF;						return ;				}				break ;			// Skip on registers not equal			case 0x9000:				if( alu != 0 )					message( "SRNE REGISTER COMPARE LOWER NIBBLE: ", alu );							if( registers[rd] != registers[rs] )					memory.pc += 2;				return ;			// Load indexer			case 0xA000:				index = addr;				return ;			// Branch indexed			case 0xB000:				memory.pc = addr + registers[0];								if( memory.pc > 0xFFF )					message("BRANCHING OUTSIDE OF NORMAL MEMORY");								return ;			// Random			case 0xC000:				registers[rd] = int(Math.random() * 0x100) & imm;				return ;			// Display Sprite			case 0xD000:				drawSprite( registers[rd], registers[rs], alu );				return ;			// Extended instructions			case 0xE000:			case 0xF000:				switch( opcode & 0xF0FF )				{				// Skip when pressed				case 0xE09E:					if( keys[registers[rd]] )						memory.pc += 2;					return ;				// Skip when released				case 0xE0A1:					if( !keys[registers[rd]] )						memory.pc += 2;					return ;				// Check delay timer				case 0xF007:					registers[rd] = delayTimer;					return ;				// Wait for Key				case 0xF00A:					keyload = rd;					return ;				// Load delay timer				case 0xF015:					delayTimer = registers[rd];					return ;				// Load sound timer				case 0xF018:					soundTimer = registers[rd];					if( beep )						beep.stop();										beep = new Beep().play(0,255);					return ;				// Increment index by register				case 0xF01E:					index = ( index + registers[rd] ) & 0xFFFF;											return ;				// Index small font				case 0xF029:					index = registers[rd] * 5 + Memory.SMALL_FONT_START;					return ;				// Index large font				case 0xF030:					index = registers[rd] * 10 + Memory.LARGE_FONT_START;					return ;				// BCD Decode register to indexed memory				case 0xF033:					memory.stream = index;					memory.writeByte( int(registers[rd] / 100) );					memory.writeByte( int(registers[rd] / 10) % 10 );					memory.writeByte( registers[rd] % 10 );					return ;				// Write registers bulk				case 0xF055:					memory.stream = index;					for( i = 0; i <= rd; i++ )						memory.writeByte( registers[i] );					return ;				// Read registers bulk				case 0xF065:					memory.stream = index;					for( i = 0; i <= rd; i++ )						registers[i] = memory.readByte();										// Write registers bulk (48mem)				case 0xF075:					memory.stream = Memory.HP48_USER_MEMORY;					for( i = 0; i <= rd; i++ )						memory.writeByte( registers[i] );					return ;				// Read registers bulk (48mem)				case 0xF085:					memory.stream = Memory.HP48_USER_MEMORY;					memory.stream = index;					for( i = 0; i <= rd; i++ )						registers[i] = memory.readByte();											return ;				}				break ;			}			throw new Error( (memory.pc-2).toString(16) + ": Unsupported instruction: " + opcode.toString(16));	    }				private function drawSprite( x:uint, y:uint, height:uint ):void		{			var double:Boolean = false;						if( height == 0 )			{							height = 16;				double = display.superchip;			}			var image:Vector.<uint> = new Vector.<uint>();			memory.stream = index;						while( height-- > 0 ) 				image.push(double ? memory.readShort() : (memory.readByte() << 8) );			// Collision detection code			registers[15] = display.drawArray(x,y,image) ? 1 : 0;		}		    }}